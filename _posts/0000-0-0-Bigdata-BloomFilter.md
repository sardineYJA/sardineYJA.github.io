---
layout: post
title: "BloomFilter 布隆过滤器"
date: 2019-09-09
description: "BloomFilter"
tag: Bigdata

---

## 背景

判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路，存储位置要么是磁盘，要么是内存。很多时候要么是以时间换空间，要么是以空间换时间。

布隆过滤器：时间和空间消耗都比较小的数据结构和算法。


## 简介

- 作用：判断一个元素是不是在一个集合里

- 实质：一个很长的二进制向量和一系列随机映射函数

- 优点：空间效率和查询时间都远远超过一般的算法

- 缺点：有一定的误识别率和删除困难


## 算法思想

当一个元素被加入集合时，通过`K个散列函数`将这个元素映射成一个位数组中的`K个点`，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。

![png](/images/posts/all/BloomFilter布隆过滤器算法思想.jpg)

- 存在误判：元素并没有在容器中，但是hash之后得到的k个位置上值都是1。

- 删除困难：放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素。


## 哈希函数选择

好的哈希函数要能近似等概率的将字符串映射到各个Bit。
选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。


## 个数选择

哈希函数个数:k，Bit数组大小:m，数据量:n，其中ln(2)约0.7

m个数：m = -1 * [n * ln(fpp误判率)] / [(ln2) * (ln2)]

k个数：（出错的概率是最小时）k = ln(2) * m/n

或者简单一点：m = k * n


## 使用场景

- 网页爬虫对URL的去重，避免爬取相同的URL地址

- 从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（垃圾短信） 


# reference

https://www.cnblogs.com/z941030/p/9218356.html

